# -*- coding: utf-8 -*-
"""Data Analysis - UFRPE

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Al02u1su2e1eJeSYY-SMIAR9VwG99OW6

*Analysis* - monitoring file
"""

with open("/content/data_monitoring_baseline.txt") as fp:
  lines = fp.readlines()

linesclear = list()
ttr = 0
ttf = 0
disponibilidade = list()
ttfs = list()
ttrs = list()

for line in lines:
  linesclear.append(line.strip())

for i in range(len(linesclear)-1):
  if linesclear[i] == 'UP':
    ttf = ttf+1
  if linesclear[i] == 'DOWN':
    ttr = ttr+1

  if ttf !=0 and ttr !=0 and linesclear[i+1] == 'UP':
    ttf = ttf*100
    ttfs.append(ttf)
    ttrs.append(ttr)
    ttr = 0
    ttf = 0

#print(disponibilidade, len(disponibilidade), a)
print(len(ttfs), len(ttrs))
print(ttfs)
print(ttrs)
#print(ttfs + ttrs)
a = sum(ttfs)/(sum(ttfs)+sum(ttrs))
print(a)

import numpy as np
import matplotlib.pyplot as plt

print("Distribution - TTFS")
plt.hist(ttfs, bins=10);

print("Distribution - TTRS")
plt.hist(ttrs, bins=10);

"""Bootstrap"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import bootstrap
dis = list
rng = np.random.default_rng()

res_mttr = bootstrap((ttrs,), np.mean, confidence_level=0.95, random_state=rng, n_resamples=10000)

res_mttf = bootstrap((ttfs,), np.mean, confidence_level=0.95, random_state=rng, n_resamples=10000)

fig, ax = plt.subplots()
ax.hist(res_mttr.bootstrap_distribution, bins=25)
ax.set_title('Bootstrap MTTR')
ax.set_xlabel('statistic value')
ax.set_ylabel('frequency')
plt.show()


fig, ax = plt.subplots()
ax.hist(res_mttf.bootstrap_distribution, bins=25)
ax.set_title('Bootstrap MTTF')
ax.set_xlabel('statistic value')
ax.set_ylabel('frequency')
plt.show()

"""

```
# Isto está formatado como código
```

Confidence Interval - MTTF e MTTR"""

print("MTTF", res_mttf.confidence_interval)

print("MTTR", res_mttr.confidence_interval)

"""Confidence Interval"""

availability_lower = res_mttf.confidence_interval.low/(res_mttf.confidence_interval.low + res_mttr.confidence_interval.low)
availability_upper = res_mttf.confidence_interval.high/(res_mttf.confidence_interval.high + res_mttr.confidence_interval.high)

print(availability_lower, availability_upper)